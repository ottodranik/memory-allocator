#include "header-helpers.h"

/* ==== Хэлперы для работы с хэдерами ==== */

/** 
 * Сдвиг влево для наполнения хэдера информацией 
 */
void shiftLeft(int *head, int n) {
	*head = *head << n;
}

/**
 * Алгоритм: побитово сравнить (И) хвост хэдера с (3 = 11 = DWORD-1) - максимально 
 * возможным значением свободных байт (DWORD - 1)
 * @return: Количество свободных байтов в слове.
 */
int getBlockFreeSize(int num) {
	return num & 3;
}

/**
 * Алгорит: сдвинуть на 3 бита (биты свободного места)
 * и сравнить с (1023 = 1111111111) - максимально возможным значением размера блока в байтах
 * @return: Размер блока в штуках DWORD.
 */
int getBlockSize(int num) {
	return num >> 3 & 1023;
}

/**
 * Алгорит: сдвинуть на 13 бит (биты свободного места и биты размера блока)
 * и сравнить с (1023 = 1111111111) - максимально возможным значением сдвига блока в байтах.
 * @return: Сдвиг от начала дампа (локальный адрес блока) в штуках DWORD.
 */
int getBlockAddress(int num) {
	return num >> 13 & 1023;
}

/**
 * Алгорит: сдвинуть на 23 бита (биты свободного места, биты размера блока 
 * и биты сдвига от начала) и сравнить с флагом 1. Если "ДА", то блок занят.
 * @return: Флаг занятости.
 */
int getBlockBusyState(int num) {
	return num >> 23 & 1;
}

/**
 * Алгорит: сдвинуть на 24 бита (биты свободного места, биты размера блока, 
 * биты сдвига от начала и бит флага) и вернуть значение.
 * @return: Флаг начала хэдера.
 */
int getBlockHeadByte(int num) {
	return num >> 24;
}

/** 
 * @return: Бинарное представление числа
 */
char *doubleWordToBinary(int x) {
	static char b[BITS_IN_BYTE * DWORD + 1];
	b[0] = '\0';
	long z;
	for (z = BITS_IN_DWORD / 2; z > 0; z >>= 1) {
		strcat(b, ((x & z) == z) ? "1" : "0");
	}
	return b;
}
